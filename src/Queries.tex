\chapter{Queries}
\label{ch:queries}
The last chapter covered in detail how the data stream is processed so that queries can be executed on the data.
This chapter now takes a closer look at the queries used for the investigation of the BHE \cite{borgwardt2015temporalizing}.
It further discusses whether the queries specified here can be expressed in the language of \cite{borgwardt2015temporalizing}.

The language of \cite{borgwardt2015temporalizing} consists of \textit{temporal queries} (TQs).
They can be based on any atemporal query language $\mathcal{Q}$.
\begin{definition}[temporal query ct.\ Definition 3.2 in \cite{borgwardt2015temporalizing}]
    \label{def:queries/temporal}
    Given a query language $\mathcal{Q}$, $temporal\ \mathcal{Q}\text{-}queries$ are built from $\mathcal{Q}$-queries as follows:
    \begin{itemize}
        \item every $\mathcal{Q}$-query $\psi$ is a temporal $\mathcal{Q}$-query; and
        \item if $\phi_{1}$ and $\phi_{2}$ are temporal $\mathcal{Q}$-queries, then so are:
        \begin{itemize}
            \item $\phi_{1} \wedge \phi_{2}$ (conjunction), $\phi_{1} \vee \phi_{2}$ (disjunction),
            \item $\Circle \phi_{1}$ (strong next), $\CIRCLE \phi_{1}$ (weak next),
            \item $\Circle^{-} \phi_{1}$ (strong previous), $\CIRCLE^{-} \phi_{1}$ (weak previous),
            \item $\Box \phi_{1}$ (always), $\Box^{-} \phi_{1}$ (always in the past),
            \item $\Diamond \phi_{1}$ (eventually), $\Diamond^{-} \phi_{1}$ (some time in the past),
            \item $\phi_{1} \mathsf{U} \phi_{2}$ (until), and $\phi_{1} \mathsf{S} \phi_{2}$ (since).
        \end{itemize}
    \end{itemize}
    The symbols $\Circle^{-}, \CIRCLE^{-}, \Box^{-}, \Diamond^{-}$, and $\mathsf{S}$ are called \textit{past operators}, the symbols $\Circle, \CIRCLE, \Box, \Diamond$, and $\mathsf{U}$ are \textit{future operators}.
\end{definition}

Since the implementation of the BHE \cite{boundedhistoryencodingalgorithm} uses an SQLite database, the atemporal query language $\mathcal{Q}$ in this thesis is SQL.

In this thesis, two different types of TQs are distinguished.
First, \textit{practical and meaningful} TQs (PTQs) and second, \textit{randomized} TQs (RTQs) based on the idea presented in \cite{schneider2019formally}.

\section{Practical Temporal Queries}
\label{sec:queries/investigationqueries/practical}
PTQs show whether the BHE \cite{borgwardt2015temporalizing} can give relevant answers to queries.
This is necessary to find out if it has practical relevance and can be used, e.g.\ for market observation as it is done in this thesis.
For reasons of readability, only the following selected queries are discussed as examples:
\begin{align}
    &\text{``Which cars cost less than 10,000 at the last time point} \label{qu:queries/investigationqueries/practical/qu1} \\
    &\text{and cost more than 10,000 at this time point?''} \nonumber
\end{align}
\begin{align}
    &\text{``Which brands (or models) have an increased average} \label{qu:queries/investigationqueries/practical/qu2} \\
    &\text{price compared to the last time point?''} \nonumber
\end{align}
\begin{align}
    &\text{``Which cars cost more than 1.000.000 at one time point} \label{qu:queries/investigationqueries/practical/qu3}\\
    &\text{during the last 6 time points?''} \nonumber
\end{align}

A complete list of PTQs can be found in Appendix \ref{ch:appendixB}.

\section{Randomized Temporal Queries}
\label{sec:queries/investigationqueries/random}
RTQs are used to verify the impact of the queries on the overall research outcome.
They are necessary because PTQs might not be sufficiently diverse to provide reliable results.
RTQs can be constructed in any size.

\begin{definition}[randomized temporal query ct. \cite{schneider2019formally}]
    \label{def:queries/investigationqueries/random/randomizedtemporalqueries}
    Let $n \in \mathbb{N} \setminus \{0\}$.
    Let $\mathsf{Ops}$ be a set of available operators.
    A $randomized$ TQ of size $n$ can be constructed by recursively constructing its subqueries as follows:
    \begin{algorithm}[H]
        \caption*{$\mathsf{randomTQ}(n)$}
        \label{alg:queries/investigationqueries/random/algorithm}
        \algsetup{linenodelimiter=}
        \renewcommand{\algorithmiccomment}[1]{// #1}
        \begin{algorithmic}[1]
            \IF{$n = 0$}
            \RETURN $\mathcal{Q}$-query $\psi$
            \ELSE
            \STATE select a random operator $op$
            \IF{$op$ is unary}
            \RETURN $op(\mathsf{randomTQ}(n-1))$
            \ELSE[$op$ is binary]
            \STATE select a random $m \in \mathbb{N} \setminus \{0\}, m < n$
            \RETURN $(\mathsf{randomTQ}(m)\ op\ \mathsf{randomTQ}(n-m-1))$
            \ENDIF
            \ENDIF
        \end{algorithmic}
    \end{algorithm}
\end{definition}

In this thesis, 100 RTQs of sizes 1 to 10 are considered.
The individual RTQs are referenced by numbers.
A complete list of generated RTQs can be found in Appendix \ref{ch:appendixB}.


\section{Expressibility}
\label{sec:queries/expressibility}
For RTQs, since only a predefined set of operators is used in the construction, any RTQ can be expressed in any desired language, i.e.\ the language of \cite{borgwardt2015temporalizing}, if $\mathsf{Ops}$ is exactly the set of operators available in this language.
In the following $\mathcal{Q}$-query $\psi$ is defined as the SQL statement ``SELECT $url$ FROM $autos$ WHERE NOT $deleted$'' which returns every car that is not sold, just to be able to recognize the difference between a query result and the whole table.

The expressibility of PTQs is not as easy to assess.
As mentioned in Chapter \ref{ch:datastream}, $autos$ is the table in which all offers are stored.
The attribute $url$ is distinct for each dataset and serves as an identifier for a car.
Hence, if the query asks for cars, it will return a set of urls.
This said, Query \ref{qu:queries/investigationqueries/practical/qu1} can be translated into the language of \cite{borgwardt2015temporalizing}
as follows:
\begin{itemize}
    \item ``[\dots] and [\dots]'' indicates the conjunction operator from \cite{borgwardt2015temporalizing},
    \item ``[\dots] at the last time point [\dots]'' indicates either a strong previous or a weak previous operator from \cite{borgwardt2015temporalizing},
    \item ``Which cars cost less than 10,000 [\dots]'' indicates the SQL statement ``SELECT $url$ FROM $autos$ WHERE $price$ $<$ 10000'' and
    \item ``[\dots] more than 10,000 [\dots]'' indicates the SQL statement ``SELECT $url$ FROM $autos$ WHERE $price$ $>$ 10000''.
\end{itemize}
Thus, a resulting query in the language of \cite{borgwardt2015temporalizing} is
\begin{align}
    &\text{``$\Circle^{-}$(SELECT $url$ FROM $autos$ WHERE $price$ $<$ 10000) } \nonumber \\
    &\text{$\wedge$ SELECT $url$ FROM $autos$ WHERE $price$ $>$ 10000''.} \nonumber
\end{align}
Query \ref{qu:queries/investigationqueries/practical/qu2} can be rewritten as follows:
\begin{itemize}
    \item ``[\dots] compared to the last time point?'' indicates the use of the conjunction operator from \cite{borgwardt2015temporalizing} with either a strong previous or a weak previous operator from \cite{borgwardt2015temporalizing} as one argument and
    \item since the query needs to compare the value of one attribute at two different points in time it needs a restriction like ``[\dots] WHERE $price1 < price2$'' with $price1$ being the average price of the first time point and $price2$ the average price of the second time point.
\end{itemize}
Thus, a resulting query might be
\begin{align}
    &\text{``$\Circle^{-}$(SELECT $marke$, AVG($price$) AS $price1$ FROM $autos$)}  \nonumber \\
    &\text{$\wedge$ SELECT $marke$, AVG($price$) AS $price2$ FROM $autos$ WHERE $price1 < price2$''.}  \nonumber
\end{align}
Notice, that this kind of more sophisticated filtering is not considered in \cite{borgwardt2015temporalizing} and therefore is also not considered in the implementation \cite{boundedhistoryencodingalgorithm}.
If expressed with the available operators in the language of \cite{borgwardt2015temporalizing}, the implementation of the BHE \cite{boundedhistoryencodingalgorithm} rewrites the query into the SQL statement
\begin{align}
    &\text{``SELECT * FROM $result\_table\_XY$ NATURAL JOIN} \nonumber \\
    &\text{(SELECT $marke$, AVG($price$) AS $price2$ FROM $autos$ WHERE $price1 < price2$)''} \nonumber
\end{align}
where $result\_table\_XY$ denotes the table that contains the answer to the subquery
\begin{align}
    &\text{``$\Circle^{-}$(SELECT $marke$, AVG($price$) AS $price1$ FROM $autos$)''.} \nonumber
\end{align}
This statement is not a valid SQL statement, as there is no such column $price1$ in the second part of the statement.
A corresponding valid SQL statement is
\begin{align}
    &\text{``SELECT * FROM (SELECT * FROM $result\_table\_XY$ NATURAL JOIN} \nonumber \\
    &\text{(SELECT $marke$, AVG($price$) AS $price2$ FROM $autos$) WHERE $price1 < price2$)''} \nonumber
\end{align}
which shows, that more sophisticated filtering can be achieved by applying another SQL statement, that contains the wanted filter, to the result of the underlying query.
Thus, to express this query in the language of \cite{borgwardt2015temporalizing}, the language needs to be extended by a \textit{filter operator}.

Furthermore, Query \ref{qu:queries/investigationqueries/practical/qu3} can be rewritten as follows:
\begin{align}
    &\text{``SELECT $url$ FROM $autos$ WHERE $price$ $>$ 1000000} \nonumber \\
    &\text{$\vee \Circle^{-}$(SELECT $url$ FROM $autos$ WHERE $price$ $>$ 1000000)} \nonumber \\
    &\text{$\vee \Circle^{-}\Circle^{-}$(SELECT $url$ FROM $autos$ WHERE $price$ $>$ 1000000)} \nonumber \\
    &\text{$\vee \Circle^{-}\Circle^{-}\Circle^{-}$(SELECT $url$ FROM $autos$ WHERE $price$ $>$ 1000000)} \nonumber \\
    &\text{$\vee \Circle^{-}\Circle^{-}\Circle^{-}\Circle^{-}$(SELECT $url$ FROM $autos$ WHERE $price$ $>$ 1000000)} \nonumber \\
    &\text{$\vee \Circle^{-}\Circle^{-}\Circle^{-}\Circle^{-}\Circle^{-}$(SELECT $url$ FROM $autos$ WHERE $price$ $>$ 1000000)''} \nonumber
\end{align}
This kind of query is highly complex when expressed in the language of \cite{borgwardt2015temporalizing}.
To simplify matters, this query would need a time limit in the form of \textit{metric temporal operators} (MTOs).

Lastly, the operators
$\Box \phi$ (always), $\Box^{-} \phi$ (always in the past), $\Diamond \phi$ (eventually), $\Diamond^{-} \phi$
(sometime in the past) were introduced in \cite{borgwardt2015temporalizing} but not considered when defining the algorithm.

Consequently, it is necessary to extend the language of \cite{borgwardt2015temporalizing} and the implementation of the BHE \cite{boundedhistoryencodingalgorithm} by these missing operators, a filter operator and MTOs.